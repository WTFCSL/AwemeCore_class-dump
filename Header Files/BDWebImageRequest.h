//
//     Generated by private class-dump
//

@class NSURL, BDImageDecoderConfig, BDImageRequestKey, BDWebImageCryptoKey, NSDictionary, BDImageCropConfig, NSMutableArray, BDImageLargeSizeMonitor, BDImagePerformanceRecoder, NSString, BDBaseTransformer, NSArray, BDBlurHashConfig, NSData, NSError, UIImage;

@interface BDWebImageRequest : NSObject {
    NSString *_requestKey;
    double _lastNotifiedProgress;
    double _beginTime;
    double _endTime;
    unsigned long long _currentIndex;
    unsigned long long _retriedCount;
    BOOL _finished;
    BOOL _needUpdateProgress;
    BOOL _isPrefetchRequest;
    BOOL _isNeedDecrptyData;
    BOOL _cancelled;
    BOOL _userDefinedMaxRetryCount;
    BDBaseTransformer *_transformer;
    NSString *_uuid;
    id _userInfo;
    NSString *_category;
    NSString *_cacheName;
    long long _insulatedCacheType;
    NSString *_bizTag;
    NSString *_sceneTag;
    NSString *_pageTag;
    NSDictionary *_customParam;
    NSDictionary *_customParamParsingInfo;
    NSURL *_currentRequestURL;
    NSArray *_alternativeURLs;
    NSDictionary *_requestHeaders;
    double _timeoutInterval;
    long long _option;
    unsigned long long _memoryLimit;
    BDBlurHashConfig *_blurHashConfig;
    BDWebImageCryptoKey *_cryptoKey;
    BDImageCropConfig *_cropConfig;
    id /* block */ _progressBlock;
    id /* block */ _completedBlock;
    id /* block */ _performanceBlock;
    id /* block */ _decryptBlock;
    UIImage *_image;
    NSData *_data;
    NSError *_error;
    NSString *_cachePath;
    double _progress;
    long long _receivedSize;
    long long _expectedSize;
    double _minNotifiProgressInterval;
    long long _maxRetryCount;
    BDImagePerformanceRecoder *_recorder;
    BDImageLargeSizeMonitor *_largeImageMonitor;
    unsigned long long _randomSamplingPointCount;
    BDImageRequestKey *_originalKey;
    BDImageDecoderConfig *_config;
    NSMutableArray *_mutableRetryInfos;
    struct CGSize { double width; double height; } _sizeLimit;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } _smartCropRect;
}

@property (class, copy, nonatomic) NSDictionary *globalCustomParamParsingInfo;
@property (class, nonatomic) unsigned long long largeImageFileSizeLimit;
@property (class, nonatomic) unsigned long long largeImageMemoryLimit;
@property (class, nonatomic) double largeImageViewResolutionScaleLimit;
@property (class, nonatomic) BOOL isMonitorDecodedImageQuality;
@property (class, nonatomic) BOOL isMonitorLargeImage;

@property (retain, nonatomic) BDImageRequestKey *originalKey;
@property (retain, nonatomic) BDImageDecoderConfig *config;
@property (nonatomic) BOOL userDefinedMaxRetryCount;
@property (retain, nonatomic) NSMutableArray *mutableRetryInfos;
@property (retain, nonatomic) BDImagePerformanceRecoder *recorder;
@property (retain, nonatomic) BDImageLargeSizeMonitor *largeImageMonitor;
@property (readonly, copy, nonatomic) NSString *uuid;
@property (retain, nonatomic) id userInfo;
@property (retain, nonatomic) NSString *requestKey;
@property (copy, nonatomic) NSString *category;
@property (copy, nonatomic) NSString *cacheName;
@property (nonatomic) long long insulatedCacheType;
@property (copy, nonatomic) NSString *bizTag;
@property (copy, nonatomic) NSString *sceneTag;
@property (copy, nonatomic) NSString *pageTag;
@property (copy, nonatomic) NSDictionary *customParam;
@property (copy, nonatomic) NSDictionary *customParamParsingInfo;
@property (readonly, retain, nonatomic) NSURL *currentRequestURL;
@property (copy, nonatomic) NSArray *alternativeURLs;
@property (readonly, nonatomic) unsigned long long currentIndex;
@property (nonatomic) BOOL isPrefetchRequest;
@property (nonatomic) BOOL isNeedDecrptyData;
@property (copy, nonatomic) NSDictionary *requestHeaders;
@property (nonatomic) double timeoutInterval;
@property (nonatomic) long long option;
@property (nonatomic) struct CGSize { double width; double height; } sizeLimit;
@property (nonatomic) unsigned long long memoryLimit;
@property (nonatomic) struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } smartCropRect;
@property (copy, nonatomic) BDBlurHashConfig *blurHashConfig;
@property (retain, nonatomic) BDWebImageCryptoKey *cryptoKey;
@property (retain, nonatomic) BDImageCropConfig *cropConfig;
@property (copy) id /* block */ progressBlock;
@property (copy) id /* block */ completedBlock;
@property (copy) id /* block */ performanceBlock;
@property (copy) id /* block */ decryptBlock;
@property (retain) UIImage *image;
@property (retain, nonatomic) NSData *data;
@property (retain, nonatomic) NSError *error;
@property (copy, nonatomic) NSString *cachePath;
@property (nonatomic) double progress;
@property (nonatomic) long long receivedSize;
@property (nonatomic) long long expectedSize;
@property (nonatomic) double minNotifiProgressInterval;
@property (nonatomic) long long maxRetryCount;
@property (retain, nonatomic) BDBaseTransformer *transformer;
@property (readonly, nonatomic, getter=isCancelled) BOOL cancelled;
@property (readonly, nonatomic, getter=isFailed) BOOL failed;
@property (readonly, nonatomic, getter=isFinished) BOOL finished;
@property (readonly, nonatomic) NSArray *retryInfos;
@property (nonatomic) unsigned long long randomSamplingPointCount;
@property (nonatomic) struct CGSize { double x0; double x1; } downsampleSize;

+ (void)setLargeImageMemoryLimit:(unsigned long long)arg0;
+ (unsigned long long)largeImageMemoryLimit;
+ (BOOL)isMonitorLargeImage;
+ (unsigned long long)largeImageFileSizeLimit;
+ (double)largeImageViewResolutionScaleLimit;
+ (BOOL)needRetryByHttps:(long long)arg0;
+ (BOOL)isMonitorDecodedImageQuality;
+ (id)defaultRetryErrorCodes;
+ (void)setIsMonitorLargeImage:(BOOL)arg0;
+ (void)addRetryErrorCode:(long long)arg0;
+ (void)removeRetryErrorCode:(long long)arg0;
+ (void)setLargeImageFileSizeLimit:(unsigned long long)arg0;
+ (void)setLargeImageViewResolutionScaleLimit:(double)arg0;
+ (void)setIsMonitorDecodedImageQuality:(BOOL)arg0;
+ (id)globalCustomParamParsingInfo;
+ (void)setGlobalCustomParamParsingInfo:(id)arg0;
+ (void)_aweLazyRegisterStaticLoad_cache_hit_rate;

- (void)setCompletedBlock:(id /* block */)arg0;
- (void)setBizTag:(id)arg0;
- (id)bizTag;
- (id)currentRequestURL;
- (void)setDecryptBlock:(id /* block */)arg0;
- (void)setExpectedSize:(long long)arg0;
- (id)initWithURL:(id)arg0 alternativeURLs:(id)arg1;
- (void)setCurrentRequestURL:(id)arg0;
- (id)mutableRetryInfos;
- (void)recordRetryInfos;
- (void)_configurePerformanceRecorderWithFrom:(long long)arg0;
- (BOOL)canRetryWithError:(id)arg0;
- (void)_callbackWithImage:(id)arg0 data:(id)arg1 from:(long long)arg2;
- (id /* block */)completedBlock;
- (id)blurHashConfig;
- (id /* block */)performanceBlock;
- (unsigned long long)randomSamplingPointCount;
- (void)_trackLargeImageMonitor;
- (id)largeImageMonitor;
- (id)sceneTag;
- (void)setSceneTag:(id)arg0;
- (void)setPageTag:(id)arg0;
- (long long)receivedSize;
- (id)cropConfig;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })smartCropRect;
- (void)setUserDefinedMaxRetryCount:(BOOL)arg0;
- (void)configGlobalMaxRetryCount:(long long)arg0;
- (void)finishWithImage:(id)arg0 data:(id)arg1 savePath:(id)arg2 url:(id)arg3 from:(long long)arg4;
- (void)thumbnailFinished:(id)arg0 from:(long long)arg1;
- (void)blurHashFinished:(id)arg0 fromNet:(BOOL)arg1;
- (void)_setReceivedSize:(long long)arg0 andExpectedSize:(long long)arg1;
- (void)_receiveProgressData:(id)arg0 finished:(BOOL)arg1 taskQueue:(id)arg2 task:(id)arg3;
- (id)retryInfos;
- (void)setCropConfig:(id)arg0;
- (void)setSizeLimitByScreenPoint:(struct CGSize { double x0; double x1; })arg0;
- (void)setDownsampleSize:(struct CGSize { double x0; double x1; })arg0;
- (struct CGSize { double x0; double x1; })downsampleSize;
- (long long)insulatedCacheType;
- (void)setInsulatedCacheType:(long long)arg0;
- (id)customParam;
- (void)setCustomParam:(id)arg0;
- (id)customParamParsingInfo;
- (void)setCustomParamParsingInfo:(id)arg0;
- (BOOL)isPrefetchRequest;
- (void)setIsPrefetchRequest:(BOOL)arg0;
- (BOOL)isNeedDecrptyData;
- (void)setIsNeedDecrptyData:(BOOL)arg0;
- (void)setSmartCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })arg0;
- (void)setBlurHashConfig:(id)arg0;
- (void)setPerformanceBlock:(id /* block */)arg0;
- (id /* block */)decryptBlock;
- (void)setReceivedSize:(long long)arg0;
- (double)minNotifiProgressInterval;
- (void)setMinNotifiProgressInterval:(double)arg0;
- (void)setLargeImageMonitor:(id)arg0;
- (void)setRandomSamplingPointCount:(unsigned long long)arg0;
- (BOOL)userDefinedMaxRetryCount;
- (void)setMutableRetryInfos:(id)arg0;
- (void)cache_hit_rate_callbackWithImage:(id)arg0 data:(id)arg1 from:(long long)arg2;
- (long long)maxRetryCount;
- (id)requestKey;
- (BOOL)isFinished;
- (BOOL)isFailed;
- (void)setMaxRetryCount:(long long)arg0;
- (id)category;
- (void)setTimeoutInterval:(double)arg0;
- (id)data;
- (void)setConfig:(id)arg0;
- (void).cxx_destruct;
- (unsigned long long)currentIndex;
- (id)transformer;
- (id)image;
- (id)config;
- (id)recorder;
- (void)setUserInfo:(id)arg0;
- (void)setData:(id)arg0;
- (id)initWithURL:(id)arg0;
- (void)setCategory:(id)arg0;
- (void)setTransformer:(id)arg0;
- (double)timeoutInterval;
- (void)setProgressBlock:(id /* block */)arg0;
- (void)setMemoryLimit:(unsigned long long)arg0;
- (void)setImage:(id)arg0;
- (void)failedWithError:(id)arg0;
- (id)userInfo;
- (void)cancel;
- (double)progress;
- (unsigned long long)memoryLimit;
- (void)setError:(id)arg0;
- (id)cachePath;
- (id)uuid;
- (void)setRecorder:(id)arg0;
- (id)cacheName;
- (id /* block */)progressBlock;
- (BOOL)isCancelled;
- (void)setRequestKey:(id)arg0;
- (void)setProgress:(double)arg0;
- (void)setOption:(long long)arg0;
- (struct CGSize { double x0; double x1; })sizeLimit;
- (id)error;
- (void)retry;
- (long long)option;
- (id)alternativeURLs;
- (void)setAlternativeURLs:(id)arg0;
- (id)cryptoKey;
- (void)setCryptoKey:(id)arg0;
- (id)pageTag;
- (void)setCachePath:(id)arg0;
- (id)requestHeaders;
- (void)setRequestHeaders:(id)arg0;
- (long long)expectedSize;
- (void)setSizeLimit:(struct CGSize { double x0; double x1; })arg0;
- (void)setCacheName:(id)arg0;
- (id)originalKey;
- (void)setOriginalKey:(id)arg0;

@end
